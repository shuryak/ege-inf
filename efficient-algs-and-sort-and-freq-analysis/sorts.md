# Сортировки

## Сортировка массива

Массив упорядочен по возрастанию, если меньшие числа в нём стоят раньше 
больших. Если мы последовательно рассмотрим все пары соседних чисел, и в каждой 
из них это свойство выполняется, то массив можно считать упорядоченным.

Проверка на упорядоченность массива по возрастанию:

```python
A = [int(x) for x in input().split()]
N = len(A)
flag = True
for i in range(N-1):
    if A[i] >= A[i + 1]:
        flag = False
print(flag)
```

## Сортировка пузырьком

Сортирующее действие: если в какой-то паре большее число стоит левее меньшего – 
нужно поменять их местами. После ОДНОГО сортирующего прохода по массиву от 
начала к концу, хотя бы одно число (самое большее) будет поставлено на своё 
место. Оно всплывёт как пузырёк.

```python
A = [3, 1, 4, 5, 2]
N = len(A)

for k in range(N - 1):
    for i in range(N - 1 - k):
        if A[i] > A[i + 1]:
            A[i], A[i + 1] = A[i + 1], A[i]
    print(A)
```

## Сортировка подсчётом:

Иногда сортируемые элементы имеют небольшой диапозон возможных значений. 
Например, необходимо отсортировать длинный список десятичных цифр. Тогда его 
возможно обработать за линейное время.

```python
A = [int(x) for x in '1893567192764591102']

scope = 10
counters = [0] * scope

for x in A:
    counters[x] += 1

i = 0
for x in range(scope):
    for k in range(counters[x]):
        A[i] = x
        i += 1
print(*A)
```

1. Для хранения частот цифр создаём вспомогательный массив `counters` с 
индексами от 0 до 9, заполненный нулями;
2. Статистически анализируем числа из `A` и записываем в `counters[x]` 
количество чисел, равных `x`;
3. Теперь проходим по порядку по всем цифрами и последовательно записываем в 
массив `A` цифру `x` `counters[x]` раз.
